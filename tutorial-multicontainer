<Multi-Container Environment>
How to Dockerize applications which rely on different services to run such as 
web apps that require a database. In particular, how you can run and manage 
multi-container environments.



# <SF Food Trucks>
The app's backend is written in Python (Flask) and for search it uses 
Elasticsearch.

- Clone the repository
(e.g., $ git clone https://github.com/prakhar1989/FoodTrucks)

- The "flask-app" folder contains the Python application, while the "utils" 
folder has some utilities to load the data into Elasticsearch.

- The application consists of a Flask backend server and an Elasticsearch 
service. A natural way to split this app would be to have two containers - 
1. One running the Flask process 
2. Another running the Elasticsearch (ES) process.

- The Flask container is already built in the repository.

- For Elasticsearch, you can find something on the hub.
(e.g., $ docker search elasticsearch)

- Pull the image (Elastic, the company behind Elasticsearch maintains its own 
registry for Elastic products. It's recommended to use the images from that 
registry if you plan to use Elasticsearch - https://www.docker.elastic.co/)
(e.g., docker pull docker.elastic.co/elasticsearch/elasticsearch:6.3.2)

- Run it in development mode by specifying ports and setting an environment 
variable that configures the Elasticsearch cluster ro run as a single-node.
(e.g., $ docker run -d --name es -p 9200:9200 -p 9300:9300 -e "discovery.type=
single-node" docker.elastic.co/elasticsearch/elasticsearch:6.3.2)
(--name es: to give our container a name which makes it easy to use in 
subsequent commands)

- Once the container is started, you can see the logs by running 
"$ docker container logs" with the container name (or ID) to inspect the logs.
($ docker container ls) - to see a list of containers you have
($ docker container logs es)

- See if you can send a request to the ELasticsearch container.
User the 9200 port to send a cURL request to the container.
(* curl is a command line tool to transfer data to or from a server, using any 
of the supported protocols (HTTP, FTP, IMAP, POP3, SCP, SFTP, SMTP, TFTP, 
TELNET, LDAP or FILE...)
(e.g., $ curl 0.0.0.0:9200)

- Now you have to create a Docker Image of the Flask app. You can create a 
Docker Image with a Dockerfile. Go to FoodTrucks folder ($ cd FoodTrucks) and 
you can find the Dockerfile.

(Dockerfile in the previous tutorial)
-----------------------------------------------------
# specify your base image
FROM python:3

# set a directory for the app
WORKDIR /usr/src/app

# copy all the files to the container
COPY . .

# install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# define the port number the container should expose
EXPOSE 5000

# run the command
CMD ["python", "./app.py"]
-----------------------------------------------------

* apart from installing Python dependencies via pip, we want our application to 
also generate our minified Javascript file for production. For this, we'll 
require Nodejs. Since we need a custom build step, we'll start from the ubuntu 
base image to build our Dockerfile from scratch.

(Dockerfile)
---------------------------------------------------------
# specify your base image
FROM ubuntu:latest

LABEL maintainer="Prakhar Srivastav <prakhar@prakhar.me>"

# install system-wide deps for python and node
RUN apt-get -yqq update
RUN apt-get -yqq install python-pip python-dev curl gnupg
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash
RUN apt-get install -yq nodejs

# copy our application code
ADD flask-app /opt/flask-app
WORKDIR /opt/flask-app

# fetch app specific deps (install dependencies)
RUN npm install
RUN npm run build
RUN pip install -r requirements.txt

# define the port number the container should expose
EXPOSE 5000

# run the command
CMD [ "python", "./app.py" ]
---------------------------------------------------------

* If you find that an existing image doesn't cater to your needs, feel free to 
start from another base image on DockerHub and tweak it yourself.

New things:
1. Use the package manager apt-get to install the dependencies namely Python and Node.
2. The yqq flag is used to suppress output and assumes "Yes" to all prompts.
3. The ADD command to copy your application into a new volume in the container 
- /opt/flask-app. This is where your code will reside. We also set this as your 
working directory, so that the following commands will be run in the context of 
this location. Now that your system-wide dependencies are installed, we get 
around to installing app-specific ones. First off we tackle Node by installing 
the packages from npm and running the build command as defined in your 
package.json file. We finish the file off by installing the Python packages, 
exposing the port and defining the CMD to run as we did in the last section.

* You are supposed to make a Docker Image that takes care of the Python 
application (the "flask-app" folder) and Elasticsearch(the "utils" folder) -> 
therefore, the Dockerfile needs to be placed in the context of FoodTrucks that 
contains both folders.

- In the same directory ($ cd FoodTrucks), command docker build
(e.g., $ docker build -t mrki102/foodtrucks-web .)

- See if your image shows
(e.g., $ docker images)

- Run the image to see if it actually works
(e.g., $ docker run -P --rm mrki102/foodtrucks-web)

- Confirm that the flask app is not able to run since it was unable to connect 
to Elasticsearch. In the following part, you will get to know how to tell one 
container about the other container and get them to talk to each other.



# <Docker Network>

- See what container do you have
($ docker container ls)

- Confirm that the "docker.elastic.co/elasticsearch/..." container is running.
The container is running on "0.0.0.0:9200 port". Meaning that it should be able 
to connect and talk to ES if you can tell your Flask app to connect to this URL.

- Go to ($ cd FoodTrucks/flask-app) and open "app.py" On the line 8, you can 
find "es = Elasticsearch(host='es')". This is the details that define the 
connection.

- To make this work, we need to tell the Flask container that the ES container 
is running on "0.0.0.0" host (the port by default is "9200"). But this is wrong.
"0.0.0.0" is the IP to access ES container from the host machine (i.e., from 
your laptop). Another container will not be able to access this on the same IP 
address.

- See all Network IDs and find the ID with the name of "bridge". That is the 
network in whcih containers are run by default. Meaning that when the ES 
container is running, it is in this bridge network.
(e.g., $ docker network ls)

- Inspect the network to validate this. confirm the "es" container is listed 
under the "Container" section in the output. What you can also see is the IP 
address. This container has been allotted - "172.17.0.2".
(e.g., $ docker network inspect bridge)

- Find out to see whether or not the IP address, "172.17.0.2", is what you are 
looking for by trying to access this IP while running your flask container.
(e.g., $ docker run -it --rm mrki102/foodtrucks-web bash) (then type this 
...-app#: curl 172.17.0.2:9200) "bash" is to start the container in the 
interactive mode with the bash process. Once you do this, you can if you can 
indeed talk to ES on "172.17.0.2:9200".

- Escape from there
(e.g., .../flask-app# exit)

- You still have to figure out two problems.
1. How do we tell the Flask container that "es" hostname stands for 
"172.17.0.2:9200" or some other IP since the IP address can change?
2. Since the bridge network is shared by every container by default, this 
approach is not secure. How do you isolate your network?

- Docker allows you to define your own networks while keep them isolated using 
the "docker network" command. Create a user-defined network with the command.
(e.g., $ docker network create foodtrucks-net)

- Confirm the network that you just created ("foodtrucks-net")
(e.g., $ docker network ls)

- Stop and remove the existing ES contianer that has been running in the default 
bridge network.
(e.g., $ docker container stop es > $ docker container rm es)

- Now you can relaunch both containers (Elasticsearch, mrki102/foodtrucks-web) 
inside this network using the "--net" flag. 
(e.g., $ docker run -d --name es --net foodtrucks-net -p 9200:9200 -p 9300:9300 
-e "discovery.type=single-node" docker.elastic.co/elasticsearch/
elasticsearch:6.3.2)

- Inspect the "foodtrucks-net" to see if the "es" container is running inside 
the "foodtrucks-net" bridge network.
(e.g., $ docker network inspect foodtrucks-net)

- Try what heppens when you launch "mrki102/foodtrucks-web" in the 
"foodtrucks-net" network. (It works!)
(e.g., $ docker run -it --rm --net foodtrucks-net mrki102/foodtrucks-web bash)
(.../flask-app# curl es:9200)
(.../flask-app# ls)
(.../flask-app# python app.py) - You can confirm the message that the app is 
running on "http://0.0.0.0:5000/". However, you can not access it with the 
browser because it is currently using the development server in a production 
environment.

- Stop and remove the "mrki102/foodtrucks-web" container and run it again.
(e.g., $ docker run -d --net foodtrucks-net -p 5000:5000 --name foodtrucks-web 
mrki102/foodtrucks-web)

- Now you can access "http://0.0.0.0:5000/" via browser.

* In summary, you can run this multi-container environment app with the 
following script. (setup-docker.sh)
--------------------------------------------------------------------------------
# build the flask container
docker build -t prakhar1989/foodtrucks-web .

# create the network
docker network create foodtrucks-net

# start the ES(Elasticsearch) container
docker run -d --name es --net foodtrucks-net -p 9200:9200 -p 9300:9300 -e 
"discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:6.3.2

# start the flask app container
docker run -d --net foodtrucks-net -p 5000:5000 --name foodtrucks-web 
prakhar1989/foodtrucks-web
--------------------------------------------------------------------------------

You can get a whole app running with just one command (./setup-docker.sh)
-----------------------------------------------------
$ git clone https://github.com/prakhar1989/FoodTrucks
$ cd FoodTrucks
$ ./setup-docker.sh
-----------------------------------------------------
